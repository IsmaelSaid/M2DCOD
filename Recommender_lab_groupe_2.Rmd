---
title: "Guide d'utilisation recommenderlab"
author: "Etienne Ismael"
date: "`r Sys.Date()`"
output:
  beamer_presentation: default
  slidy_presentation: default
  ioslides_presentation: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library("recommenderlab")
```

# Partie 1.
## Chargement des fichiers
Nous travaillons avec les données anime. Ces données représentent les notes attribuées aux animés par 5000 utilisateurs.
Les données sont au format dat.
La méthode read.csv() lit un fichier au format table et créer un dataframe à partir de ces données
```{r echo = TRUE}
# read_csv retourne un data.frame
anime_history <-read.csv("datasets/anime/anime_history.dat",
                         header = TRUE,
                         sep = "\t")
anime_info <-read.csv("datasets/anime/anime_info.dat",
                      header = TRUE,
                      sep = "\t")
anime_ratings <-read.csv("datasets/anime/anime_ratings.dat",
                         header = TRUE,
                         sep = "\t")

class(anime_ratings) # données au format dataframe
```

## Rappels sur les data.frame
C'est une structure pour stocker des jeux de données.
Pour accèder aux elements d'un dataframe, nous utilisons les brackets [lignes,colonnes]
```{r echo=TRUE,  results='hide'}
anime_ratings[1:5,1:3] #lignes 1 à 5, colonnes 1 à 3
anime_ratings[1:5, c("User_ID","Anime_ID","Feedback")]
# Cette ligne ralentit considéralement l'exportation en pdf. 
# anime_ratings[-c(1, 2)]  #uniquement la colonne 3
summary(anime_ratings) #statistique de base
```

```{r echo=FALSE}
knitr::kable(anime_ratings[1:5,1:3])
```

## Coercition

La coercition consiste à convertir un objet en une classe donnée. Par défaut, read.csv retourne un data.frame. Il est nécessaire de le transformer vers un format adapté pour pouvoir y faire des opérations supplémentaires.


## Coercition du data.frame vers un objet realratingsMatrix

Il est plus facile de sélectionner les utilisateurs et les items que l'on souhaite manipuler et les comparer avec les realrattingsmatrix.
Un objet realratingsmatrix stocke les données dans un format sparse Matrix qui enregistre uniquement les valeurs non vides.
Les valeurs vides sont représentées par le caractère "."


```{r, echo=TRUE,results='hide'}
rrm_anime <- as(anime_ratings,'realRatingMatrix')
# opération inverse 
head(as(rrm_anime,'data.frame'))
head(getRatingMatrix(rrm_anime)) #affiche la matrice au format sparse Matrix
```

```{r echo=FALSE}
knitr::kable(head(as(rrm_anime,'data.frame')))
```

## Fonctions intéressantes realRatingsMatrix

-   nratings
-   dim
-   colCounts
-   rowCounts
-   colMeans
-   rowMeans

## Propriétés des données

```{r,echo=TRUE,results='hide'}
dim(rrm_anime) #  4714 Lignes 7157 colonnes  
nratings(rrm_anime) # 419943 notes
```

## Donneés interessantes

```{r echo=TRUE}
head(colMeans(rrm_anime)) # signification
head(colCounts(rrm_anime)) # signification 
head(rowCounts(rrm_anime)) # signification
```

## Visualisation realRatingsMatrix

```{r, echo=TRUE}
image(rrm_anime[1:10,1:30])
```

## Histogramme

```{r, fig.width = 10,echo=TRUE}
hist(getRatings(rrm_anime),breaks = 10,labels = TRUE)
```

## Normalisation

<!-- La normalisation tente de réduire le biais de notation individuel en centrant les données par ligne. On a le choix d'utiliser une normalisation par centrage (défaut) ou par zscore. Par centre: On soustrait chaque note disponible de la moyenne des notes de cet utilisateur (ligne) On peut normaliser les notes avec la fonction normalize. La fonction prend en argument un objet RealRatingMatrix -->

```{r, echo=TRUE}
#normalisation par centre
nrrmx_anime_ratings =  normalize(rrm_anime)
head(getRatings(nrrmx_anime_ratings))
#normalisation par z-score
nzrrmx_anime_ratings <- normalize(rrm_anime, method="Z-score")
head(getRatings(nzrrmx_anime_ratings))
```

## Histogramme des notes normalisées

```{r,echo=TRUE}
hist(getRatings(normalize(rrm_anime)),breaks=100)
```

## Binarisation des données

La binarisation permet de réduire la note à un avis positif (1) ou un avis négatif (0). La facon la plus simple de binariser est d'utiliser la fonction binarize().On peut fixer un seuil de notation.


```{r}
brmx_anime_ratings <- as(anime_ratings,'binaryRatingMatrix')
#les notes qui sont à >=  minRating sont positif
anime_binary <- binarize(rrm_anime, minRating=4)
class(anime_binary)
# getRatings(anime_binary)
```

## Visualisation binary ratings matrix

On peut aussi visualiser les binary ratings matrix avec la méthode image.

```{r}
  #image(brmx_anime_ratings[1:10,1:30])
  image(anime_binary[1:10,1:30])
  as(anime_binary[1:10,1:30], "matrix")
```
# Evaluation des modèles de recommendations

## Mise en situation 

## Etape 1 : identifier le problème
Qu'est ce que je pourrais bien lui recommander ?
```{r,echo=TRUE}
image(rrm_anime[1:1,1:25])
```


## Etape 2 : Comprendre les données
-   $X \in \mathbb{R}^{4714}$ Ensemble des utilisateurs
-   $S \in \mathbb{R}^{7157}$ Ensemble des Animés
-   constat : notes biaisées

### Comprendre les données
```{r,echo=FALSE}
nb_lignes=dim(rrm_anime)[1]
nb_items=dim(rrm_anime)[2]
boxplot(data.frame(global = colMeans(rrm_anime[1:nb_lignes,1:nb_items])))
```

## Etape 3 : Préparer ses données
```{r,echo=FALSE,results='hide'}
e <- evaluationScheme(
  train = 0.9,
  normalize(rrm_anime),
  method="split",
  given=1,
  goodRating=0)
```
### Séparer ses données
```R
evaluationScheme(data, method, train, k...)
```

### Normaliser ses données
```R
normalise(data, method, train, k...)

```
### Vérifiez les répartitions des notes 
```{r,echo=FALSE,fig.}
custom_summary = data.frame(
  training = colMeans(getData(e,"train")),
  known = colMeans(getData(e,"know"))
)
boxplot(custom_summary)
```

## Etape 4 : Créer des modèles de recommendations

## Etape 5 : Evaluer des modèles de recommendations